<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Valhalla Debug</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
    }

    #map {
      flex: 1;
      position: relative;
    }

    #sidebar {
      width: 300px;
      padding: 10px;
      background: white;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      z-index: 2;
      display: flex;
      flex-direction: column;
    }

    textarea,
    input,
    button,
    label,
    select {
      width: 100%;
      box-sizing: border-box;
      margin-bottom: 10px;
      padding: 5px;
    }

    button {
      margin-top: auto;
    }

    #error-message {
      color: red;
      font-weight: bold;
    }

    .popup-content {
      max-width: 600px;
      max-height: 400px;
      overflow-y: auto;
    }
  </style>
</head>

<body>
  <div id="sidebar">
    <textarea id="locations" rows="6" placeholder="Enter locations JSON here... or click on the map"></textarea>
    <textarea id="parameters" rows="25" placeholder="Enter parameters JSON here...">
{"units":"kilometers", "costing":"auto","costing_options":{"auto":{"maneuver_penalty":5,"country_crossing_penalty":0,"country_crossing_cost":600,"width":1.6,"height":1.9,"use_highways":1,"use_tolls":1,"use_ferry":1,"ferry_cost":300,"use_living_streets":0.5,"use_tracks":0,"private_access_penalty":450,"ignore_closures":false,"ignore_restrictions":false,"ignore_access":false,"closure_factor":9,"service_penalty":15,"service_factor":1,"exclude_unpaved":1,"shortest":false,"exclude_cash_only_tolls":false,"top_speed":140,"fixed_speed":0,"toll_booth_penalty":0,"toll_booth_cost":15,"gate_penalty":300,"gate_cost":30,"include_hov2":false,"include_hov3":false,"include_hot":false,"disable_hierarchy_pruning":false}}}</textarea>
    <div>
      <button id="do-route">Do route</button>
      <button id="do-expansion">Do expansion</button>
      <label for="slider">Graph expansion progress:</label>
      <input id="slider" type="range" min="0" max="1.0" value="1.0" step="0.001" />
      <label id="edges-count">Explored 0 edges</label>
      <div>
        <label for="route-summary">Route summary:</label>
        <textarea id="route-summary" rows="11" cols="50"></textarea>
      </div>
      <button id="do-traffic">Show traffic</button>
    </div>
    <div id="error-message"></div>
  </div>
  <div id="map"></div>
  <script>
    mapboxgl.accessToken = "{{MAPBOX_ACCESS_TOKEN}}";
    const map = new mapboxgl.Map({
      container: "map",
      style: "mapbox://styles/mapbox/streets-v11",
      center: [13.15792, 55.668221],
      zoom: 11,
    });

    map.on("load", function () {
      map.addSource("route", {
        type: "geojson",
        data: {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: []
          }
        }
      });
      map.addLayer({
        id: "route-line",
        type: "line",
        source: "route",
        layout: {
          "line-join": "round",
          "line-cap": "round",
        },
        paint: {
          "line-color": "#007AFF",
          "line-width": 9,
        }
      });

      // Source for drawing traffic lines based on information from /locate response
      map.addSource("traffic-lines", {
        type: "geojson",
        data: {
          type: "FeatureCollection",
          features: [],
        },
      });
      map.addLayer({
        id: "traffic-lines",
        type: "line",
        source: "traffic-lines",
        layout: {},
        paint: {
          // Set the line color based on the jam factor
          "line-color": [
            "interpolate",
            ["linear"],
            ["get", "jamFactor"], // Access the jam factor property
            0.0, "#33cc33", // Green for no traffic
            2.5, "#ffcc00", // Yellow for moderate traffic
            5.0, "#ffb700", // Orange for medium traffic
            7.5, "#ff0000", // Red for heavy traffic
            10., "#000000", // Black for blocked roads
          ],
          "line-width": 5,
        }
      });

      // This source will be filled by data later in the button callback handler
      map.addSource("expansion", {
        type: "geojson",
        data: {
          type: "FeatureCollection",
          features: [],
        },
      });
      map.addLayer({
        id: "expansion-edges",
        type: "line",
        source: "expansion",
        layout: {},
        paint: {
          "line-color": [
            "interpolate",
            ["linear"],
            ["get", "progress"],
            // From Violet-Pink Gradient color scheme for progress
            0.0, "#AF1281", // Start color
            0.5, "#CF268A",
            1.0, "#E65C9C", // End color
          ],
          // Interpolate width to show if same line is covered multiple times
          "line-width": [
            "interpolate",
            ["linear"],
            ["get", "progress"],
            0,
            3, // Start width
            1.0, // progress is changing from 0.0 to 1.0
            1, // End width
          ],
        },
      });

      let locations;
      try {
        locations = JSON.parse(document.getElementById("locations").value);
      } catch (e) {
        locations = []
      }
      showMarkers(locations);

      // Function to update the visibility of lines based on slider value
      const showLinesForProgress = (progress) => {
        map.setFilter("expansion-edges", ["<=", ["get", "progress"], progress]);
      };

      // Initial update with the full range of lines
      showLinesForProgress(1.0);

      // Event listener for the slider
      document.getElementById("slider").addEventListener("input", (event) => {
        const value = parseFloat(event.target.value);
        showLinesForProgress(value);
      });

      map.on("contextmenu", (e) => {
        const locations = [
          {
            lat: e.lngLat.lat,
            lon: e.lngLat.lng,
            radius: 500.0, // unfortunately bigger numbers give nothing
          },
        ];

        sendValhallaRequest("locate", locations, { verbose: true })
          .then((response) => response.json())
          .then((data) => {
            let edge;
            let popup_coord;
            try {
              edge = data[0]["edges"][0];
              popup_coord = [edge["correlated_lon"], edge["correlated_lat"]];
            } catch {
              edge = data;
              popup_coord = e.lngLat;
            }
            const popupContent = `<div class="popup-content">
                  <pre>${JSON.stringify(edge, null, 2)}</pre>
              </div>`;

            new mapboxgl.Popup().setLngLat(popup_coord).setHTML(popupContent).addTo(map);

            // // Update the traffic-lines source with the new data
            // map.getSource("traffic-lines").setData({
            //   type: "FeatureCollection",
            //   features: data[0]["edges"].map(to_traffic_flow).filter(flow => flow !== null).flat(),
            // });
          })
          .catch((err) => {
            console.error("Bad /locate response: ", err);
            const popup = new mapboxgl.Popup()
              .setLngLat(e.lngLat)
              .setHTML(`<p>Bad <b>/locate</b> response: ${err.message}</p>`)
              .addTo(map);
          });
      });

      document.getElementById("do-route").addEventListener("click", () => {
        const errorMessage = document.getElementById("error-message");

        let locations;
        try {
          locations = JSON.parse(document.getElementById("locations").value);
        } catch (e) {
          locations = []
        }
        showMarkers(locations);

        // clear the previous lines to clearly indicate that new request is in progress
        map.getSource("expansion").setData({
          type: "FeatureCollection",
          features: [],
        });

        // Set empty data
        map.getSource("route").setData({
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: []
          }
        });

        document.getElementById("route-summary").textContent = "";

        if (locations.length < 2) {
          errorMessage.textContent = "At least 2 locations is required";
          return;
        }

        sendValhallaRequest("route", locations, {})
          .then((response) => response.json())
          .then((data) => {
            // Draw route polyline
            map.getSource("route").setData({
              type: "Feature",
              geometry: {
                type: "LineString",
                coordinates: data["trip"]["legs"].map((leg) => decodePolyline6(leg["shape"])).flat()
              }
            });

            // Show route summary
            let summary = "";
            for (const [key, value] of Object.entries(data["trip"]["summary"])) {
              summary += `"${key}": ${JSON.stringify(value)}\n`
            }
            document.getElementById("route-summary").textContent = summary;

            // Clear error message
            errorMessage.textContent = "";
          })
          .catch((err) => {
            errorMessage.textContent = "Bad /route response: " + err;
          });
      });


      document.getElementById("do-expansion").addEventListener("click", () => {
        const errorMessage = document.getElementById("error-message");

        let locations;
        try {
          locations = JSON.parse(document.getElementById("locations").value);
        } catch (e) {
          locations = []
        }
        showMarkers(locations);

        // clear the previous lines to clearly indicate that new request is in progress
        map.getSource("expansion").setData({
          type: "FeatureCollection",
          features: [],
        });

        if (locations.length < 2) {
          errorMessage.textContent = "At least 2 locations is required";
          return;
        }

        document.getElementById("edges-count").textContent = "Exploring...";
        sendValhallaRequest("expansion", locations, { action: "route" })
          .then((response) => response.json())
          .then((data) => {
            if (!data.type || data.type !== "FeatureCollection") {
              errorMessage.textContent = "Invalid /expansion response: " + JSON.stringify(data);
              return;
            }

            // progress is changing from 0.0 for the first line to the 1.0 for the last line
            const total = data.features.length - 1;
            document.getElementById("edges-count").textContent = `Explored ${total} edges`;
            data.features.forEach((feature, i) => {
              feature.properties.progress = i / total;
            });
            map.getSource("expansion").setData(data);

            // Reset the slider and show all lines
            document.getElementById("slider").value = 1.0;
            showLinesForProgress(1.0);

            // Clear error message
            errorMessage.textContent = "";
          })
          .catch((err) => {
            errorMessage.textContent = "Bad /expansion response: " + err;
          });
      });

      document.getElementById("do-traffic").addEventListener("click", () => {
        const bounds = map.getBounds();
        const bbox = `${bounds.getSouth()},${bounds.getWest()};${bounds.getNorth()},${bounds.getEast()}`;
        // todo: probably we want to limit road graph level based on a zoom level
        fetch(`${window.location.href}/api/traffic/${bbox}`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
          },
        })
          .then((response) => response.json())
          .then((data) => {
            const features = Object.entries(data).map(([shape, jamFactor]) => {
              return {
                type: "Feature",
                geometry: {
                  type: "LineString",
                  coordinates: decodePolyline6(shape),
                },
                properties: {
                  jamFactor: jamFactor,
                },
              };
            });
            // Update the traffic-lines source with the new data
            map.getSource("traffic-lines").setData({
              type: "FeatureCollection",
              features: features,
            });

            // Clear error message
            errorMessage.textContent = "";
          })
          .catch((err) => {
            errorMessage.textContent = "Bad /api/traffic/ response: " + err;
          });;
      });
    });

    function sendValhallaRequest(endpoint, locations, addons) {
      const parametersInput = document.getElementById("parameters").value;
      const errorMessage = document.getElementById("error-message");

      let parameters;
      try {
        parameters = JSON.parse(parametersInput);
      } catch (e) {
        errorMessage.textContent = "Invalid Parameters JSON.";
        return;
      }

      return fetch(`${window.location.href}/api/request`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          endpoint: endpoint,
          payload: {
            locations: locations,
            ...addons,
            ...parameters,
          },
        }),
      });
    }

    function showMarkers(locations) {
      // Remove existing markers
      document.querySelectorAll(".mapboxgl-marker").forEach((marker) => marker.remove());

      locations.forEach((location, index) => {
        const color = index === 0 ? "green" : index === locations.length - 1 ? "red" : "gray";
        const marker = new mapboxgl.Marker({ color: color, draggable: true }).setLngLat([location.lon, location.lat]).addTo(map);
        marker.on('dragend', () => {
          const newCoords = marker.getLngLat();

          const locations = JSON.parse(document.getElementById("locations").value || '[]');
          locations[index].lon = newCoords.lng;
          locations[index].lat = newCoords.lat;
          displayLocations(locations);
        });
      });
      displayLocations(locations);
    }

    map.on('click', (e) => {
      const locations = JSON.parse(document.getElementById("locations").value || '[]');
      const newLocation = {
        lon: e.lngLat.lng,
        lat: e.lngLat.lat,
        type: 'break'
      };
      locations.push(newLocation);
      showMarkers(locations);
    });

    function displayLocations(locations) {
      document.getElementById("locations").value = JSON.stringify(locations, function (key, value) {
        // limit precision of floats
        if (typeof value === 'number') {
          return parseFloat(value.toFixed(5));
        }
        return value;
      });
    }

    // Decodes polyline into array of [lon, lat] points
    function decodePolyline6(encoded) {
      let currentPosition = 0;
      const len = encoded.length;

      function zigzagDecode(val) {
        return ((val & 1) ? ~(val >> 1) : (val >> 1));
      }

      function readVarint() {
        let shift = 0;
        let result = 0;
        let byte;

        do {
          byte = encoded.charCodeAt(currentPosition++) - 63;
          result |= (byte & 0x1f) << shift;
          shift += 5;
        } while (byte >= 0x20);

        return result;
      }

      let lat = 0;
      let lng = 0;
      const coordinates = [];
      while (currentPosition < len) {
        lat += zigzagDecode(readVarint());
        lng += zigzagDecode(readVarint());
        coordinates.push([lng * 1e-6, lat * 1e-6]);  // Use 1e-6 for Polyline6
      }

      return coordinates;
    }

    // Fast approximate distance between two [lon, lat] points
    function calcShortDist(from, to) {
      // Earth's radius in meters
      const R = 6371000.0;
      // Convert degrees to radians
      const lat1Rad = from[1] * Math.PI / 180;
      const lat2Rad = to[1] * Math.PI / 180;
      const lonDiffRad = (from[0] - to[0]) * Math.PI / 180;

      // Calculate the approximate shortest-distance path
      return 2.0 * Math.PI * R * Math.sqrt(
        (Math.cos(lat2Rad) * Math.abs(lonDiffRad) / (2 * Math.PI)) ** 2 +
        (Math.abs(from[1] - to[1]) / 360) ** 2
      );
    }

    // Converts edge from the "/locate" response to the geojson feature that represents traffic flow
    function to_traffic_flow(edge) {
      const edgeLiveSpeed = edge["live_speed"];
      if (!edgeLiveSpeed || !("breakpoint_0" in edgeLiveSpeed) || !("breakpoint_1" in edgeLiveSpeed)) {
        return null; // Return early if live_speed is missing
      }

      // Split edge into 3 pieces
      const length = edge["edge"]["geo_attributes"]["length"];
      const shape = decodePolyline6(edge["edge_info"]["shape"]);
      const breakpoint_0 = length * (edgeLiveSpeed["breakpoint_0"] || 0.0);
      const breakpoint_1 = length * (edgeLiveSpeed["breakpoint_1"] || 0.0);
      const { speed_0, speed_1, speed_2 } = edgeLiveSpeed; // Destructure speeds
      let segments = [];
      let traversed = 0.0
      let breakpoint_0_index = 0;
      for (let i = 0; i < shape.length - 1; i++) {
        const step = calcShortDist(shape[i], shape[i + 1]);
        if (speed_0 != speed_1 && traversed < breakpoint_0 && breakpoint_0 <= traversed + step) {
          segments.push([speed_0, shape.slice(0, i + 2)]);
          breakpoint_0_index = i + 1;
        }
        if (traversed < breakpoint_1 && breakpoint_1 <= traversed + step) {
          if (speed_1 != speed_2) {
            segments.push([speed_1, shape.slice(breakpoint_0_index, i + 1)]);
            segments.push([speed_2, shape.slice(i)]);
          } else {
            segments.push([speed_2, shape.slice(breakpoint_0_index)]);
          }
          break;
        }
        traversed += step;
      }

      // Extract speed limit
      const edgeInfo = edge["edge_info"];
      let speedLimit = edgeInfo["speed_limit"];
      if (speedLimit === "unlimited" || speedLimit === 255 || speedLimit === 0) {
        speedLimit = null; // 0 means unknown and 255 is unlimited. Both are not meaningful in our case
      }

      // Determine which speed to use for comparison
      const edgeSpeeds = edge["edge"]["speeds"];
      const freeFlowSpeed = speedLimit ?? (edgeSpeeds["free_flow"] || edgeSpeeds["default"]);

      // Return the GeoJSON feature for every segment
      return segments.map(segment => {
        return {
          type: "Feature",
          geometry: {
            type: "LineString",
            coordinates: segment[1],
          },
          properties: {
            jamFactor: 10.0 - 10.0 * Math.min(segment[0] / freeFlowSpeed, 1.0),
          },
        };
      });
    }
  </script>
</body>

</html>
